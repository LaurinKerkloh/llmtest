module Llmtest
  # Class to track coverage of a part of a source file. Extracts coverage from JSON files generated by SimpleCov.
  class CoverageTracker
    # @param coverage_path [Pathname] Path to the coverage JSON file.
    # @param source_path [Pathname] Path to the source file that the coverage tracker should track.
    # @param relevant_lines [Range] Range of lines in the source file that the coverage tracker should track.
    def initialize(coverage_path, source_path, relevant_lines)
      @coverage_path = coverage_path
      @source_path = source_path
      @relevant_lines = relevant_lines
    end

    # Record coverage of the relevant lines and branches.
    #
    # @return [void]
    def record_coverage
      coverage = parse_coverage_file

      @line_coverage = get_line_coverage(coverage)
      @branch_coverage = get_branch_coverage(coverage)
    end

    # Record newly covered lines and branches.
    #
    # @return [Array<Array<Integer>, Array<Hash>>] Newly covered lines and branches.
    def newly_covered
      coverage = parse_coverage_file

      lines_newly_covered = []
      get_line_coverage(coverage).each_with_index do |line_coverage, index|
        if line_coverage && line_coverage >= 1 && @line_coverage[index] == 0
          lines_newly_covered << index + 1
          @line_coverage[index] = line_coverage
        end
      end

      branches_newly_covered = []
      get_branch_coverage(coverage).each_with_index do |branch, index|
        if branch["coverage"] >= 1 && @branch_coverage[index]["coverage"] == 0
          branches_newly_covered << branch
          @branch_coverage[index]["coverage"] = branch["coverage"]
        end
      end

      [lines_newly_covered, branches_newly_covered]
    end

    # Check if all lines and branches are covered.
    #
    # @return [Boolean] Whether all lines and branches are covered.
    def fully_covered?
      all_lines_covered = uncovered_lines.empty?
      all_branches_covered = uncovered_branches.empty?

      all_lines_covered && all_branches_covered
    end

    def to_s
      # "Coverable Lines: #{@line_coverage.compact.size - 1}\n" \
      # "Coverable Branches: #{@branch_coverage.size}\n" \
      "CoverageTracker:\n" \
      "lines: #{@line_coverage}\n" \
      "branches: #{@branch_coverage.join("\n")}\n"
    end

    # Get the uncovered lines.
    #
    # @param in_original_file [Boolean] Whether to return the line numbers in the original file.
    # @return [Array<Integer>] The uncovered lines.
    def uncovered_lines(in_original_file: false)
      uncovered_lines = @line_coverage.filter_map.with_index { |coverage, index| index + 1 if coverage == 0 }

      return uncovered_lines unless in_original_file

      uncovered_lines.map { |line| line + @relevant_lines.begin - 1 }
    end

    # Get the uncovered branches.
    #
    # @param in_original_file [Boolean] Whether to return the line numbers in the original file.
    # @return [Array<Hash>] The uncovered branches.
    def uncovered_branches(in_original_file: false)
      uncovered_branches = @branch_coverage.filter_map { |branch| branch if branch["coverage"] == 0 }

      return uncovered_branches unless in_original_file

      uncovered_branches.each do |branch|
        branch["start_line"] += @relevant_lines.begin
        branch["end_line"] += @relevant_lines.begin
      end
      uncovered_branches
    end

    private

    def parse_coverage_file
      JSON.parse(@coverage_path.read).dig("coverage", @source_path.to_s)
    end

    def get_line_coverage(file_coverage)
      # the lines array is 0-indexed so we shift the relevant line numbers by 1
      file_coverage["lines"][(@relevant_lines.begin - 1)..(@relevant_lines.end - 1)]
    end

    def get_branch_coverage(file_coverage)
      branches = file_coverage["branches"].select { |branch| @relevant_lines.include?(branch["start_line"]) }
      branches.each do |branch|
        branch["start_line"] -= @relevant_lines.begin
        branch["end_line"] -= @relevant_lines.begin
      end
    end
  end
end
